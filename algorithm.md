算法初识:https://zhuanlan.zhihu.com/p/94064549

1.算法的复杂度计算思想===>根据输入参数与计算的次数进行推算,若参数发生变化但是算法执行的次数的不变,则算法复杂度为O(1),若为正比变化则为O(n),
===>出现嵌套循环的时候,计算的总次数为n*n===>即复杂度为O(n^2);

2.二分法的思想是缩小边界进行比较===>取中与之比,等则返之,大则右等中,小则左等中,反复比之;
===>二分法的复杂度计算,数组的长度为N,每次取一半比较,只有当取一半后的那个中间值为想查找的值才能结束,但最坏的情况是取到最后一个数,因此复杂度即为做了多少次取半的操作,即N*(1/2)^X=1==>log2(1/N)=X
===>注意都要假设执行次数为X后进行计算即可得出复杂度;
===>二分法是在有序数列中根据值查找索引位置,核心点在于求中值位置==>mid=(right-left)/2+left;结束条件为left<=right
https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484284&idx=1&sn=8c4d26bd5857c93593ac65b8763cd0ef&chksm=fa0e6cfdcd79e5eb18114c6d1528c1edf304c79fd2837831f58812903b0029a5bb7a59b640ba&scene=21#wechat_redirect
https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247486565&idx=3&sn=28bc1c28f58cb3127638826a341d66cb&chksm=fa0e63e4cd79eaf200f617247927d83ef229385d42790e58ddf7cff004b226e9fb499d554fe2&scene=21#wechat_redirect

3.贪心算法是使用局部最优解最终组装得到整体最优解的近似解;重点在于制定贪心策略(比如按照从大到小的顺序),然后根据贪心策略分解为子问题,然后为每个子问题求最优解,合并结果;

4.动态规划的几个步骤:
===>问题拆解
===>状态定义,此时应该使用n,n-1等表示出题目的关系
===>写出递推公式
===>实现中找到初始值定义,并按照递推公式递推;
===>核心都是找出n和n-1的关系,然后可以递推到0;

5.分治算法是类似穷举找到规律,比如二分法,或者全排序种类(看哪个数字开头);

6.递归是通过找到递推公式以及终止条件,并将二者结合进行代码实现;
===>递归本质是用了栈的数据结构加一个简单的逻辑算法实现了业务功能;
===>递归分解子问题时可能存在重复计算,解决方案是通过散列表来保存计算结果,每次开始计算前都从HashMap中检查是否有结果,有则取之,没有就计算结果并将结果存入HashMap中;

7.hash算法的两个要求是:
===>很难根据hash值反推出原始数据;
===>散列冲突的概率要小;
===>hash算法的应用:安全加密(MD5),唯一标识(比如取图片的前100个字节进行hash算法后校验),数据校验(比如下载大文件需要进行文件拆分,然后需要使用hash值验证数据有效性),散列函数(比如hashmap中的撕裂函数,更关注散列后的值是否能均匀分布),负载均衡,数据分片,分布式存储;

8. Bcrupt加密:特点是同样的密码每次生成不同的密文,那怎么实现用户密码的正确性校验呢,原理是通过取出数据库的加密hash串,然后从hash串中取出盐值,并通过该盐值和用户输入的密码组合再次加密,最后比对二者的加密是否一致实现;
===>核心是盐值直接存储到了加密后的字符串中,无需在数据库中单独存储盐值,防止了数据暴露的可能性;
===>所有的安全措施,只是增加攻击成本而已;

9.hash值进行负载均衡算法:
===>假设不用hash值负载均衡,则需要设置客户端和服务器的session的映射表;
===>使用映射表如果客户端很多,则映射表会很大,浪费内存空间;
===>客户端上线下线都会导致映射表失效,这样维护映射表的成本很大;
===>解决办法是对客户端ip或者会话ID进行hash值,然后根据hash值与服务器列表的大小进行取模运算,得到路由服务器的编号;从而实现同一个ip过来的所有请求都路由到同一个服务器上;

10.hash值进行数据分片和d分布式存储:
===>可以先将数据进行hash之后对机器总数进行取模确定数据存放的机器编号,在取数查找的时候也只需要将数据进行hash之后再对机器总数取模之后确定要到哪台机器上取数即可;
===>注意该方法如果增加机器之后会导致取模之后的编号发生变化,因此在增加机器的时候需要对原有数据进行搬运,这样会导致缓存失效,出现雪崩效应;
===>解决方法是使用一致性hash算法:
===>一致性hash算法:hash算法是对机器总数进行取模,但是一致性hash算法是对2^32(2^32数据相当于一个环)进行取模,因此只需要将服务器ip进行hash之后再对2^32进行取模即可;
===>一致性hash容易出现偏斜,因此需要增加虚拟节点来平衡,虚拟节点是指将真实节点进行位置偏移之后作为虚拟节点,实现负载均衡,好处是一致性hash算法在增加或者删除机器都只会让少部分的缓存失效;

11.树数据结构:
===>高度:从下往上,0为起始;
===>深度:从上往下,0为起始,与高度相反;
===>层:从上往下,1为起始,深度+1;

12.二叉树:
===>二叉树是指每个节点最多只有两个节点,即左子节点和右子节点;


''



